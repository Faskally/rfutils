% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add1drop1.R
\name{add1drop1}
\alias{add1drop1}
\title{Up-down model selection}
\usage{
add1drop1(
  model,
  scope,
  smoothTerms,
  notLinear,
  essential,
  criterion,
  cluster = NULL,
  byExpand = FALSE,
  calcLogLik,
  fitModels = TRUE,
  retainModels = TRUE
)
}
\arguments{
\item{model}{detail}

\item{scope}{detail}

\item{smoothTerms}{detail}

\item{notLinear}{detail}

\item{essential}{detail}

\item{criterion}{detail}

\item{cluster}{detail}

\item{byExpand}{detail}

\item{calcLogLik}{detail}

\item{fitModels}{detail}

\item{retainModels}{detail}
}
\description{
At each stage of model selection it was possible to drop interaction
terms involving the categorical variables, replace smooth functions
of the continuous variables with linear e<U+FB00>ects and drop the
main effects of categorical and continuous variables (provided they
were not involved in any interactions or expressed as smooth functions).
It was also possible to introduce interactions between the continuous
variables and Life-stage and Pass, to allow for di<U+FB00>erent
relationships for fry and parr and for the <U+FB01>rst and subsequent
pass capture probabilities. Two-way interactions were also considered
between Lifestage and HA, and up to three-way interactions Life-stage,
Year and Organisation
}
\details{
scope is the maximal model which, for simplicity, is expressed only using linear terms.
So, if
smoothTerms = list(
altitude = "s(altitude, k = 3)",
dayOfYear = "s(dayOfYear, k = 3)",
network = "s(network, k = 4)",
hydroArea = "s(hydroArea, k = 4, bs = \"tp\")",
longitude = t2(longitude, latitude)
)
then
scope = pass * lifestage * (altitude + dayOfYear + longitude)
denotes a maximal model
pass + lifestage + pass:lifestage + s(altitude, k = 3, by = pass:lifestage) +
s(dayOfYear, k = 3, by = pass:lifestage) + t2(longitude, latitude, by = pass:lifestage)
NB Don't use : in scope and don't use 1 unless it is the null model (which is pretty pointless)
NB Still need to sort out code when by is used with more that one variable
Currently, the term s(x, by = y:z) is actually fitted as s(x, by = y) + s(x, by = z) + s(x, by = y:z)
If you get models like this turning up in the model selection, interpret them with great care!
smoothTerms gives the form of the smoother for each term in the model
NB for a 2 or 3 dimensional smoother, just give the first term - these smoothers must also
be identified in the notLinear argument
notLinear specifies the smoothers which are not reduced to a linear term before being dropped
e.g. notLinear = "hydroArea" would consider dropping the hydroArea term completely, rather than
introducing hydroArea as a factor (which doesn't make sense because that is a more complicated model)
essential specifies terms that must be in every model
these must not be the same as any terms in the scope (or even related to them in any way)
leave any offset out of this - dealt with separately
criterion (default = AIC) is a function which allows the user to define the model selection criterion
cluster is the identity of a cluster to allow parallel processing
drop1.efp and other terms (model, the data set used, scope and smoothTerms) must previously be
exported to cluster using clusterExport
byExpand = FALSE (default) is designed for use when the by variables are factors - fits a separate
smoother for each level of the factor, but with no main effect (of the covariate)
byExpand = TRUE is for when there is a single by variable and it is continuous - fits both the
main effect of the covariate (as a smoother) and the product of the by variable and a different smooth
of the covariate
calcLogLik (default = logLik) allows for a more general log likelihood calculation, for example, in
gam models with random effects, where you would want to use the marginal (integrated) likelihood in
calcLogLik = function(model) -model$gcv.ubre is the obvious choice
fitModels = TRUE (default) fits all the candidate model
fitModels = FALSE just returns the list of candidate models without fitting - useful if you want
to just check which terms come in and drop out
retainModels = TRUE (default) returns the updated model
retainModels = FALSE just returns the updated model formula - saves memory
utility functions - throughout id is the identity of a covariate in smoothTerms
and rhs is a character vector of model terms
converts rhs to single formula-like string
}
\references{
Malcom et al. 2019. Development of a large-scale juvenile density model to inform the assessment
and management of Atlantic salmon (Salmo salar) populations in Scotland
}
